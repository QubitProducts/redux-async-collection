import _ from 'lodash'
import when from 'when'
import sinon from 'sinon'
import axios from 'axios'
import { expect } from 'chai'
import delay from 'when/delay'
import Immutable from 'immutable'
import thunkMiddleware from 'redux-thunk'
import createCollection from '../createCollection'
import { REQUEST_TIMEOUT } from '../createCollection'
import { createStore, combineReducers, applyMiddleware } from 'redux'

describe('createCollection', () => {
  let get
  let res
  let data
  let store
  let result
  let sandbox
  let barId
  let collection
  let fooId
  let expectedUrl
  let requestConfig

  beforeEach(() => {
    fooId = 123
    barId = 'B-12'
    get = sinon.spy(() => res)
    sandbox = sinon.sandbox.create()
    sandbox.stub(axios, 'get', get)
    requestConfig = { timeout: REQUEST_TIMEOUT }
    expectedUrl = createUrl(fooId, barId)
    collection = createCollection('Thing', createUrl)
    store = createStoreForCollection(collection)
  })

  afterEach(() => {
    sandbox.restore()
  })

  describe('when the entity\'s name is a weird plural', () => {
    it('should properly pluralize it', () => {
      expect(createCollection('Property').properties).to.exist
    })
  })

  describe('when a fetch has not started', () => {
    beforeEach(() => {
      data = [{
        id: 1, name: 'foo'
      }, {
        id: 2, name: 'bar'
      }]
      res = when({ status: 200, data })

      return fetchThings(fooId, barId, 2)
    })

    it('should return the item', () => {
      expect(result.item).to.eql(Immutable.fromJS(data[1]))
    })

    it('should call make a valid http request', () => {
      expect(get).to.be.calledWith(expectedUrl, requestConfig)
    })

    it('should return the items', () => {
      expect(result.items).to.eql(Immutable.fromJS(data))
    })

    it('should say we have fetched', () => {
      expect(result.hasFetched).to.eql(true)
    })

    it('should NOT say there was an error', () => {
      expect(result.hasFailedToFetch).to.eql(false)
    })

    it('should NOT say were loading the items', () => {
      expect(result.isFetching).to.eql(false)
    })
  })

  describe('when a path is specified and a fetch has completed', () => {
    beforeEach(() => {
      collection = createCollection({
        name: 'Thing',
        createUrl,
        path: 'nested'
      })
      const things = collection.things
      store = applyMiddleware(thunkMiddleware)(createStore)(combineReducers({ nested: combineReducers({ things }) }))
      data = [{
        id: 1, name: 'foo'
      }, {
        id: 2, name: 'bar'
      }]
      res = when({ status: 200, data })

      return fetchThings(fooId, barId, 2, 'nested')
    })

    it('should return the item', () => {
      expect(result.item).to.eql(Immutable.fromJS(data[1]))
    })
  })

  describe('when a previous fetch has completed and I refresh the items', () => {
    beforeEach(() => {
      collection = createCollection({
        name: 'Thing',
        createUrl,
        path: 'nested'
      })
      const things = collection.things
      store = applyMiddleware(thunkMiddleware)(createStore)(combineReducers({ nested: combineReducers({ things }) }))
      data = [{
        id: 1, name: 'foo'
      }, {
        id: 2, name: 'bar'
      }]
      res = when({ status: 200, data })

      return fetchThings(fooId, barId, 2, 'nested')
    })

    beforeEach(() => {
      store.dispatch(collection.refreshThings(fooId, barId))
    })

    it('should have called get again', () => {
      expect(get).calledTwice
    })
  })

  describe('when I add an item', () => {
    let expectedThing

    beforeEach(() => {
      data = [{
        id: 1, name: 'foo'
      }]
      res = when({ status: 200, data })

      return fetchThings(fooId, barId, 2)
    })

    beforeEach(() => {
      expectedThing = {
        id: 2, name: 'bar'
      }
      addThing(fooId, barId, expectedThing)

      return fetchThings(fooId, barId, 2)
    })

    it('should add the item', () => {
      expect(result.item).to.eql(Immutable.fromJS(expectedThing))
      expect(result.items.size).to.eql(2)
    })
  })

  describe('when I delete an item', () => {
    beforeEach(() => {
      data = [{
        id: 1, name: 'foo'
      }, {
        id: 2, name: 'bar'
      }, {
        id: 3, name: 'baz'
      }]
      res = when({ status: 200, data })

      return fetchThings(fooId, barId, 2)
    })

    beforeEach(() => {
      deleteThing(fooId, barId, 2)

      return fetchThings(fooId, barId, 2)
    })

    it('should delete the item', () => {
      expect(result.item).to.eql(undefined)
      expect(result.items.size).to.eql(2)
    })
  })

  describe('when I update an item', () => {
    beforeEach(() => {
      data = [{
        id: 1, name: 'foo'
      }, {
        id: 2, name: 'bar'
      }, {
        id: 3, name: 'baz'
      }]
      res = when({ status: 200, data })

      return fetchThings(fooId, barId, 2)
    })

    beforeEach(() => {
      updateThing(fooId, barId, { id: 2, name: 'quux' })

      return fetchThings(fooId, barId, 2)
    })

    it('should update the item', () => {
      expect(result.item).to.eql(Immutable.fromJS({ id: 2, name: 'quux' }))
      expect(result.items.size).to.eql(3)
    })
  })

  describe('when a fetch is in progress', () => {
    beforeEach(() => {
      let deferred = when.defer()
      res = deferred.promise

      return fetchThings(fooId, barId).then(() => {
        get.reset()

        return fetchThings(fooId, barId)
      })
    })

    it('should NOT make any http requests', () => {
      expect(get).to.not.be.called
    })

    it('should NOT return any items', () => {
      expect(result.items).to.eql(undefined)
    })

    it('should NOT say we have fetched', () => {
      expect(result.hasFetched).to.eql(false)
    })

    it('should NOT say there was an error', () => {
      expect(result.hasFailedToFetch).to.eql(false)
    })

    it('should say were loading the items', () => {
      expect(result.isFetching).to.eql(true)
    })
  })

  describe('when a fetch has failed', () => {
    beforeEach(() => {
      res = when.reject({ status: 500 })

      return fetchThings(fooId, barId)
    })

    describe('when you try to fetch again', () => {
      beforeEach(() => {
        get.reset()

        return fetchThings(fooId, barId)
      })

      it('should NOT make any http requests', () => {
        expect(get).to.not.be.called
      })
    })

    it('should NOT return any items', () => {
      expect(result.items).to.eql(undefined)
    })

    it('should NOT say we have fetched', () => {
      expect(result.hasFetched).to.eql(false)
    })

    it('should say there was an error', () => {
      expect(result.hasFailedToFetch).to.eql(true)
    })

    it('should NOT say were loading the items', () => {
      expect(result.isFetching).to.eql(false)
    })
  })

  function createStoreForCollection ({ fetchThings, things }) {
    const createStoreWithMiddleware = applyMiddleware(thunkMiddleware)(createStore)
    return createStoreWithMiddleware(combineReducers({ things }))
  }

  function addThing (fooId, barId, experience) {
    store.dispatch(collection.addThing(fooId, barId, experience))
  }

  function deleteThing (fooId, barId, id) {
    store.dispatch(collection.deleteThing(fooId, barId, id))
  }

  function updateThing (fooId, barId, thing) {
    store.dispatch(collection.updateThing(fooId, barId, thing))
  }

  function fetchThings (fooId, barId, id, path = []) {
    store.dispatch(collection.fetchThings(fooId, barId))

    return delay(1).then(getResult)

    function getResult () {
      const things = _.get(store.getState(), [].concat(path).concat('things'))

      result = {
        isFetching: things.isFetching(fooId, barId),
        hasFetched: things.hasFetched(fooId, barId),
        items: things.getAllThings(fooId, barId),
        item: things.getThingById(fooId, barId, id),
        hasFailedToFetch: things.hasFailedToFetch(fooId, barId)
      }
    }
  }

  function createUrl (fooId, barId) {
    return `http://${fooId}/${barId}`
  }
})
